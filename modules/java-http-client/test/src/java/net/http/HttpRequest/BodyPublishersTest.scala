import java.net.http.HttpRequest.BodyPublishers
import java.nio.ByteBuffer
import java.nio.file.Files
import java.nio.file.Path
import java.io.ByteArrayInputStream
import java.io.IOException
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.Flow

import snhttp.testkits.MockSubscriber

class BodyPublishersTest extends munit.FunSuite {

  test("noBody publisher is instance of BodyPublisher") {
    val publisher = BodyPublishers.noBody()
    assert(publisher.isInstanceOf[Flow.Publisher[ByteBuffer]])
  }

  test("ofString publishes correct bytes and contentLength") {
    val str = "Hello, World!"
    val publisher = BodyPublishers.ofString(str)
    // val subscriber = MockSubscriber[ByteBuffer]()
    // publisher.subscribe(subscriber)
    // subscriber.subscription.request(10)
    // assert(subscriber.waitForCompletion(1000))
    // val received = subscriber.received.flatMap(buf => buf.array().take(buf.limit()))
    // assertEquals(received, str.getBytes(UTF_8).toList)
    // assertEquals(publisher.contentLength(), str.getBytes(UTF_8).length.toLong)
  }

  test("ofByteArray publishes correct bytes and contentLength") {
    val arr = Array[Byte](1, 2, 3, 4, 5)
    // val publisher = BodyPublishers.ofByteArray(arr)
    // val subscriber = MockSubscriber[ByteBuffer]()
    // publisher.subscribe(subscriber)
    // subscriber.subscription.request(10)
    // assert(subscriber.waitForCompletion(1000))
    // val received = subscriber.received.flatMap(buf => buf.array().take(buf.limit()))
    // assertEquals(received, arr.toList)
    // assertEquals(publisher.contentLength(), arr.length.toLong)
  }

  // works now but  hang out
  test("ofByteArray with offset/length publishes correct slice") {
    // val arr = Array[Byte](10, 20, 30, 40, 50)
    // val publisher = BodyPublishers.ofByteArray(arr, 1, 3)
    //   val subscriber = MockSubscriber[ByteBuffer]()
    //   publisher.subscribe(subscriber)
    //   subscriber.subscription.request(10)
    //   assert(subscriber.waitForCompletion(1000))
    //   val received =
    //     subscriber.received.flatMap(buf => buf.array().slice(buf.position(), buf.limit()))
    //   assertEquals(received, arr.slice(1, 4).toList)
    //   assertEquals(publisher.contentLength(), 3L)
  }

  // test("ofByteArrays publishes all arrays as ByteBuffers") {
  //   val arrays = Seq(Array[Byte](1, 2), Array[Byte](3, 4, 5))
  //   val publisher = BodyPublishers.ofByteArrays(arrays)
  //   val subscriber = MockSubscriber[ByteBuffer]()
  //   publisher.subscribe(subscriber)
  //   subscriber.subscription.request(10)
  //   assert(subscriber.waitForCompletion(1000))
  //   val received = subscriber.received.flatMap(buf => buf.array().take(buf.limit()))
  //   assertEquals(received, arrays.flatten)
  // }

  // will hang out
  test("ofInputStream publishes bytes from InputStream") {
    val arr = Array[Byte](42, 43, 44)
    val is = ByteArrayInputStream(arr)
    // val publisher = BodyPublishers.ofInputStream(() => is)
    // val subscriber = MockSubscriber[ByteBuffer]()
    // publisher.subscribe(subscriber)
    // subscriber.subscription.request(10)
    // assert(subscriber.waitForCompletion(1000))
    // val received = subscriber.received.flatMap(buf => buf.array().take(buf.limit()))
    // assertEquals(received, arr.toList)
  }

  test("ofInputStream with null InputStream delivers error") {
    // val publisher = BodyPublishers.ofInputStream(() => null)
    // val subscriber = MockSubscriber[ByteBuffer]()
    // publisher.subscribe(subscriber)
    // subscriber.subscription.request(1)
    // assert(subscriber.waitForError(1000))
    // assert(subscriber.hasError)
    // assert(subscriber.error.isInstanceOf[IOException])
  }

  // construct successfully but hang out
  // test("ofFile publishes file contents as ByteBuffers") {
  //   val tmp = Files.createTempFile("bodytest", ".bin")
  //   val arr = Array[Byte](99, 100, 101, 102)
  //   try {
  //     Files.write(tmp, arr)
  //     val publisher = BodyPublishers.ofFile(tmp)
  //     // val subscriber = MockSubscriber[ByteBuffer]()
  //     // publisher.subscribe(subscriber)
  //     // subscriber.subscription.request(10)
  //     // assert(subscriber.waitForCompletion(1000))
  //     // val received = subscriber.received.flatMap(buf => buf.array().take(buf.limit()))
  //     // assertEquals(received, arr.toList)
  //     // assertEquals(publisher.contentLength(), arr.length.toLong)
  //   } finally Files.deleteIfExists(tmp)
  // }

  // test("ofFile with missing file delivers error") {
  //   val tmp = Path.of("/tmp/nonexistent-file-" + System.nanoTime())
  //   val publisher = BodyPublishers.ofFile(tmp)
  //   val subscriber = MockSubscriber[ByteBuffer]()
  //   publisher.subscribe(subscriber)
  //   subscriber.subscription.request(1)
  //   assert(subscriber.waitForError(1000))
  //   assert(subscriber.hasError)
  // }

  // test("noBody publisher completes immediately with empty buffer") {
  //   val publisher = BodyPublishers.noBody()
  //   val subscriber = MockSubscriber[ByteBuffer]()
  //   publisher.subscribe(subscriber)
  //   subscriber.subscription.request(1)
  //   assert(subscriber.waitForCompletion(1000))
  //   assertEquals(subscriber.received.size, 1)
  //   assertEquals(subscriber.received.head.remaining(), 0)
  //   assertEquals(publisher.contentLength(), 0L)
  // }

  // test("concat with multiple publishers delivers all in order") {
  //   val arr1 = Array[Byte](1, 2)
  //   val arr2 = Array[Byte](3, 4, 5)
  //   val pub1 = BodyPublishers.ofByteArray(arr1)
  //   val pub2 = BodyPublishers.ofByteArray(arr2)
  //   val publisher = BodyPublishers.concat(pub1, pub2)
  //   val subscriber = MockSubscriber[ByteBuffer]()
  //   publisher.subscribe(subscriber)
  //   subscriber.subscription.request(10)
  //   assert(subscriber.waitForCompletion(1000))
  //   val received = subscriber.received.flatMap(buf => buf.array().take(buf.limit()))
  //   assertEquals(received, arr1.toList ++ arr2.toList)
  //   assertEquals(publisher.contentLength(), (arr1.length + arr2.length).toLong)
  // }

  test("concat with no publishers is noBody") {
    // val publisher = BodyPublishers.concat()
    // val subscriber = MockSubscriber[ByteBuffer]()
    // publisher.subscribe(subscriber)
    // subscriber.subscription.request(1)
    // assert(subscriber.waitForCompletion(1000))
    // assertEquals(subscriber.received.size, 1)
    // assertEquals(subscriber.received.head.remaining(), 0)
    // assertEquals(publisher.contentLength(), 0L)
  }

  // test("concat with one publisher is identity") {
  //   val arr = Array[Byte](7, 8, 9)
  //   val pub = BodyPublishers.ofByteArray(arr)
  //   val publisher = BodyPublishers.concat(pub)
  //   val subscriber = MockSubscriber[ByteBuffer]()
  //   publisher.subscribe(subscriber)
  //   subscriber.subscription.request(10)
  //   assert(subscriber.waitForCompletion(1000))
  //   val received = subscriber.received.flatMap(buf => buf.array().take(buf.limit()))
  //   assertEquals(received, arr.toList)
  //   assertEquals(publisher.contentLength(), arr.length.toLong)
  // }

}
